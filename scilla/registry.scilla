scilla_version 0

import BoolUtils ListUtils

library RegistryLib

(* START: PsudoStandardLib *)
(* The PsudoStandardLib is a standard list of values that we have defined for *)
(* all scilla contracts see scilla/psuedo_standard.scillib for all the details *)

let zeroUint64 = Uint64 0
let zeroByStr20 = 0x0000000000000000000000000000000000000000
let zeroByStr32 = 
  0x0000000000000000000000000000000000000000000000000000000000000000
let nilByStr20 = Nil {ByStr20}
let nilMessage = Nil {Message}

let oneMsg =
  fun(msg: Message) =>
    Cons {Message} msg nilMessage

let eqByStr20 =
  fun(bs1: ByStr20) =>
  fun(bs2: ByStr20) =>
    builtin eq bs1 bs2

let listByStr20Contains = 
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let listMemByStr20 = @list_mem ByStr20 in
      listMemByStr20 eqByStr20 bs list

let listByStr20Excludes =
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let b = listByStr20Contains list bs in negb b

let listByStr20FilterOut = 
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let listByStr20Filter = @list_filter ByStr20 in
    let fn = fun(v: ByStr20) => builtin eq v bs in
      listByStr20Filter fn list

(* XAND Gate *)
let xandb =
  fun(b1: Bool) =>
  fun(b2: Bool) =>
    match b1 with
    | True =>
      match b2 with
      | True => True
      | False => False
      end
    | False =>
      match b2 with
      | True => False
      | False => True
      end
    end
(* END: PsudoStandardLib *)

(* START: Events *)
(* Events defines a the "constructors" for all the types of events used *)
(* inside ZNS *)
let eAdminSet =
  fun(address: ByStr20) =>
  fun(isApproved: Bool) =>
    {_eventname: "AdminSet"; address: address; isApproved: isApproved}

let eApprovedFor =
  fun(user: ByStr20) =>
  fun(operator: ByStr20) =>
  fun(isApproved: Bool) =>
    {_eventname: "ApprovedFor"; user: user; operator: operator; isApproved: isApproved}

let eApproved =
  fun(address: ByStr20) =>
    {_eventname: "Approved"; address: address}

let eNewRegistrar =
  fun(address: ByStr20) =>
    {_eventname: "NewRegistrar"; address: address}

let eNewDomain = 
  fun(parent: ByStr32) =>
  fun(label: String) =>
    {_eventname: "NewDomain"; parent: parent; label: label}

let eTransfered = 
  fun(node: ByStr32) =>
  fun(owner: ByStr20) =>
    {_eventname: "Transfered"; node: node; owner: owner}

let eConfigured = 
  fun(node: ByStr32) =>
  fun(owner: ByStr20) =>
  fun(resolver: ByStr20) =>
    {_eventname: "Configured"; owner: owner; resolver: resolver}
(* We use the Error event to alert the caller if something went wrong because *)
(* Scilla doesn't support throwing *)
let codeSuccess = Uint32 0
let eCodeFailure = Uint32 1
let eCodeFailureIAM = Uint32 2
let eCodeFailureNoRecord = Uint32 3

let eError =
  fun(msg: String) =>
  fun(errorCode: Uint32) =>
      {_eventname: "Error"; msg: msg; code: errorCode }
(* END: Events *)

(* START: User Defined ADTs (Algebraic DataType) *)
(* Record represents an entry in the ZNS Tree *)
type Record = 
| Record of ByStr20 ByStr20

let recordMemberOwner =
  fun(maybeRecord: Option Record) =>
    match maybeRecord with
    | None => zeroByStr20
    | Some record =>
      match record with
      | Record owner resolver => owner
      end
    end
(* END: User Defined ADTs *)

(* START: Miscilanious Functions *)
let parentLabelToNode = 
  fun(parent: ByStr32) =>
  fun(label: String) =>
    let labelHash = builtin sha256hash label in
    let nodeInput = builtin concat parent labelHash in
      builtin sha256hash nodeInput

let getIsOwner = 
  fun(sender: ByStr20) =>
  fun(maybeRecord: Option Record) =>
    match maybeRecord with
    | None => False
    | Some record =>
      match record with 
      | Record owner _ =>
        builtin eq sender owner
      end
    end

let getIsOAO =
  fun(sender: ByStr20) =>
  fun(recordOwner: ByStr20) =>
  fun(maybeApproved: Option ByStr20) =>
  fun(maybeOperators: Option (List ByStr20)) =>
    let isOwner = builtin eq sender recordOwner in
    let isApproved = 
      match maybeApproved with
      | None => False
      | Some approved => builtin eq sender approved
      end in
    let isOperator = match maybeOperators with
    | None => False
    | Some operators => listByStr20Contains operators sender
    end in
    let b1 = orb isOwner isApproved in orb b1 isOperator
(* END: Miscilanious Functions *)

(* The 'contract' pragma tells scilla that the contract body starts *)
contract Registry 

(* START: Initial Parameters *)
(* Initial Parameters are specified on deploy, in the init.json and cannot be *)
(* changed throughout the life of the contract *)

(* initialOwner specifies the owner of the ZNS Root. See records field below. *)
(initialOwner: ByStr20,
 initialRegistrar: ByStr20)

(* END: Initial Parameters *)

(* START: Mutable Fields *)
(* Mutable Fields represent the persistant state of a scilla contract and can *)
(* use the Initial Parameters durring contract instantiation *)

(* records is the representation of the ZNS record tree as a mapping of a *)
(* Node IDs (ByStr32) to ZNS records (Record) *)
(* We initialize the field, so the contracts' initialOwner owns the ZNS root *)
field records: Map ByStr32 Record = 
  let empty = Emp ByStr32 Record in 
  let rootRecord = Record initialOwner zeroByStr20 in
    builtin put empty zeroByStr32 rootRecord

field registrar: ByStr20 = initialRegistrar

(* approvals and operators are the internal representation of the erc721 like *)
(* IAM system that ZNS uses *)
field approvals: Map ByStr32 ByStr20 = Emp ByStr32 ByStr20
field operators: Map ByStr20 (List ByStr20) = Emp ByStr20 (List ByStr20)
field admins: List ByStr20 = Cons {ByStr20} initialOwner nilByStr20
(* END: Mutable Fields *)

(* START: Admin Transitions *)
transition setAdmin(address: ByStr20, isApproved: Bool)
  currentAdmins <- admins;

  isSenderAdmin = listByStr20Contains currentAdmins _sender;

  match isSenderAdmin with
  | True =>
    needsToChange = 
      let b = listByStr20Excludes currentAdmins address in xandb b isApproved;

    match needsToChange with
    | True =>
      newAdmins = match isApproved with
        | True => Cons {ByStr20} address currentAdmins
        | False => listByStr20FilterOut currentAdmins address
        end;

      admins := newAdmins;

      e = eAdminSet address isApproved;
      event e
    | _ => (* Q?: Should I put an event here *)
    end
  | False => 
    e = let m = "Sender not root node owner" in eError m eCodeFailureIAM;
    event e
  end
end

transition approve(node: ByStr32, address: ByStr20) 
  maybeRecord <- records[node];

  isSenderNodeOwner = getIsOwner _sender maybeRecord;

  match isSenderNodeOwner with
  | True =>
    maybeApproved <- approvals[node];

    currentlyApproved = match maybeApproved with
      | None => zeroByStr20
      | Some approved => approved
      end;

    needsToChange = let b = builtin eq currentlyApproved address in negb b;

    match needsToChange with
    | True =>
      approvals[node] := address;

      e = eApproved address;
      event e
    | _ => (* Q?: Should I put an event here *)
    end
  | False =>
    e = let m = "Sender not node owner" in eError m eCodeFailureIAM;
    event e
  end
end

transition approveFor(address: ByStr20, isApproved: Bool)
  maybeOperators <- operators[_sender];

  currentOperators = match maybeOperators with
    | None => nilByStr20
    | Some ops => ops
    end;

  needsToChange = let b = listByStr20Excludes currentOperators address in 
    xandb b isApproved;

  match needsToChange with
  | True =>
    newOperators = match isApproved with 
      | True => Cons {ByStr20} address currentOperators
      | False => listByStr20FilterOut currentOperators address
      end;

    operators[_sender] := newOperators;

    e = eApprovedFor _sender address isApproved;
    event e
  | _ => (* Q?: Should I put an event here *)
  end
end
(* END: Admin Transitions *)

(* START: Name Transitions *)
transition configure(node: ByStr32, owner: ByStr20, resolver: ByStr20) 
  maybeRecord <- records[node];
  maybeApproved <- approvals[node];
  recordOwner = recordMemberOwner maybeRecord;
  maybeOperators <- operators[recordOwner];

  isSenderOAO = getIsOAO _sender recordOwner maybeApproved maybeOperators;

  match isSenderOAO with
  | True =>
    newRecord = Record owner resolver;
    records[node] := newRecord;

    e = eConfigured node owner resolver;
    event e
  | False =>
    e = let m = "Sender not node owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end

transition transfer(node: ByStr32, owner: ByStr20)
  maybeRecord <- records[node];
  maybeApproved <- approvals[node];
  recordOwner = recordMemberOwner maybeRecord;
  maybeOperators <- operators[recordOwner];

  isSenderOAO = getIsOAO _sender recordOwner maybeApproved maybeOperators;

  match isSenderOAO with
  | True =>
    approvals[node] := zeroByStr20;
    newRecord = Record owner zeroByStr20;
    records[node] := newRecord;

    e = eConfigured node owner zeroByStr20;
    event e;

    msgs = let m = {_tag: "onZNSTransfer"; node: node; 
                    _amount: Uint128 0; _recipient: owner} 
      in oneMsg m;
    send msgs
  | False =>
    e = let m = "Sender not node owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end

transition assign(parent: ByStr32, label: String, owner: ByStr20)
  maybeRecord <- records[parent];
  maybeApproved <- approvals[parent];
  recordOwner = recordMemberOwner maybeRecord;
  maybeOperators <- operators[recordOwner];

  isSenderOAO = getIsOAO _sender recordOwner maybeApproved maybeOperators;

  match isSenderOAO with
  | True =>
    node = parentLabelToNode parent label;

    recordExists <- exists records[node];
    match recordExists with
    | False =>
      e = eNewDomain parent label;
      event e
    | _ => 
    end;

    approvals[node] := zeroByStr20;
    newRecord = Record owner zeroByStr20;
    records[node] := newRecord;

    e = eTransfered node owner;
    event e
  | False =>
    e = let m = "Sender not parent owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end
(* END: Name Transitions *)

(* START: Admin Transitions *)
transition bestow(parent: ByStr32, label: String, owner: ByStr20, resolver: ByStr20)
  currentAdmins <- admins;
  node = parentLabelToNode parent label;
  recordExists <- exists records[node];
  maybeRecord <- records[node];
  currentRegistrar <- registrar;

  isOk = 
    let isSenderAdmin = listByStr20Contains currentAdmins _sender in
    let isSenderRegistrar = builtin eq currentRegistrar _sender in
    let isOkSender = orb isSenderRegistrar isSenderAdmin in
    let recordOwner = recordMemberOwner maybeRecord in
    let recordIsUnowned = builtin eq recordOwner zeroByStr20 in
      andb isOkSender recordIsUnowned;

  match isOk with
  | True =>
    match recordExists with
    | False =>
      e = eNewDomain parent label;
      event e
    | _ => 
    end;

    approvals[node] := zeroByStr20;
    newRecord = Record owner resolver;
    records[node] := newRecord;

    e = eTransfered node owner;
    event e
  | False =>
    e = let m = "Sender admin" in eError m eCodeFailureIAM;
    event e
  end
end
(* END: Admin Transitions *)

(* START: Reciever Transitions *)
transition setRegistrar(address: ByStr20)
  currentAdmins <- admins;

  isOk = listByStr20Contains currentAdmins _sender;

  match isOk with
  | True => 
    e = eNewRegistrar address;
    event e;
    registrar := address
  | _ => 
  end
end

transition register(address: ByStr20, parent: ByStr32, label: String)
  node = parentLabelToNode parent label;
  maybeRecord <- records[node];
  maybeApproved <- approvals[node];
  recordOwner = recordMemberOwner maybeRecord;
  approved =
    match maybeApproved with
    | None => zeroByStr20
    | Some approved => approved
    end;
  currentRegistrar <- registrar;

  isOk =
    let isRecordUnowned = builtin eq recordOwner zeroByStr20 in
    let isUnapproved = builtin eq approved zeroByStr20 in
      andb isRecordUnowned isUnapproved;

  match isOk with 
  | True =>
    accept;
    msgs = 
      let m = {_tag: "register"; _amount: _amount; _recipient: currentRegistrar;
               origin: _sender; node: node; parent: parent; label: label} in
        oneMsg m;
    send msgs
  | False =>
  end
end
(* END: Reciever Transitions *)
