scilla_version 0

import BoolUtils ListUtils

library AORegistryLib

(* START: PsudoStandardLib *)
(* The PsudoStandardLib is a standard list of values that we have defined for *)
(* all scilla contracts see scilla/psuedo_standard.scilla for all the details *)

let zeroUint64 = Uint64 0
let zeroByStr20 = 0x0000000000000000000000000000000000000000
let zeroByStr32 = 
  0x0000000000000000000000000000000000000000000000000000000000000000
let nilByStr20 = Nil {ByStr20}
let nilMessage = Nil {Message}

let oneMsg =
  fun(msg: Message) =>
    Cons {Message} msg nilMessage

let eqByStr20 =
  fun(bs1: ByStr20) =>
  fun(bs2: ByStr20) =>
    builtin eq bs1 bs2

let listByStr20Contains = 
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let listMemByStr20 = @list_mem ByStr20 in
      listMemByStr20 eqByStr20 bs list

let listByStr20Excludes =
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let b = listByStr20Contains list bs in negb b

let listByStr20FilterOut = 
  fun(list: List ByStr20) =>
  fun(bs: ByStr20) =>
    let listByStr20Filter = @list_filter ByStr20 in
    let fn = fun(v: ByStr20) => builtin eq v bs in
      listByStr20Filter fn list

let xandb =
  fun(b1: Bool) =>
  fun(b2: Bool) =>
    match b1 with
    | True =>
      match b2 with
      | True => True
      | False => False
      end
    | False =>
      match b2 with
      | True => False
      | False => True
      end
    end
(* END: PsudoStandardLib *)

(* START: Events *)
(* Events defines a the "constructors" for all the types of events used *)
(* inside ZNS *)
let eAdminSet =
  fun(address: ByStr20) =>
  fun(isApproved: Bool) =>
    {_eventname: "AdminSet"; address: address; isApproved: isApproved}

let eApprovedFor =
  fun(user: ByStr20) =>
  fun(operator: ByStr20) =>
  fun(isApproved: Bool) =>
    {_eventname: "ApprovedFor"; user: user; operator: operator; isApproved: isApproved}

let eApproved =
  fun(address: ByStr20) =>
    {_eventname: "Approved"; address: address}

let eNewDomain = 
  fun(parent: ByStr32) =>
  fun(label: String) =>
    {_eventname: "NewDomain"; parent: parent; label: label}

let eTransfered = 
  fun(node: ByStr32) =>
  fun(owner: ByStr20) =>
    {_eventname: "Transfered"; node: node; owner: owner}

let eConfigured = 
  fun(node: ByStr32) =>
  fun(owner: ByStr20) =>
  fun(resolver: ByStr20) =>
    {_eventname: "Configured"; owner: owner; resolver: resolver}
(* We use the Error event to alert the caller if something went wrong because *)
(* Scilla doesn't support throwing *)
let codeSuccess = Uint32 0
let eCodeFailure = Uint32 1
let eCodeFailureIAM = Uint32 2
let eCodeFailureNoRecord = Uint32 3

let eError =
  fun(msg: String) =>
  fun(errorCode: Uint32) =>
      {_eventname: "Error"; msg: msg; code: errorCode }
(* END: Events *)

(* START: Messages *)
let mOnZNSRecordReceived =
  fun(recipient: ByStr20) =>
  fun(origin: ByStr20) =>
  fun(amount: Uint128) =>
  fun(node: String) =>
  fun(parent: Uint32) =>
  fun(label: Uint32) =>
  fun(owner: Uint32) =>
  fun(resolver: Uint32) =>
    {_tag: "onZNSRecordReceived"; _amount: amount; _recipient: recipient; 
     origin: origin; node: node; parent: parent; label: label; 
     owner: owner; resolver: resolver}

let mBlank =
  fun(recipient: ByStr20) =>
  fun(amount: Uint128) =>
    {_tag: ""; _amount: amount; _recipient: recipient}
(* END: Messages *)

(* START: User Defined ADTs (Algebraic DataType) *)

(* Record represents an entry in the ZNS Tree *)
type Record = 
| Record of ByStr20 ByStr20

let recordMemberOwner =
  fun(maybeRecord: Option Record) =>
    match maybeRecord with
    | None => zeroByStr20
    | Some record =>
      match record with
      | Record owner resolver => owner
      end
    end
(* END: User Defined ADTs *)

(* START: Miscilanious Functions *)

let parentLabelToNode = 
  fun(parent: ByStr32) =>
  fun(label: String) =>
    let labelHash = builtin sha256hash label in
    let nodeInput = builtin concat parent labelHash in
      builtin sha256hash nodeInput

let getIsOwner = 
  fun(sender: ByStr20) =>
  fun(maybeRecord: Option Record) =>
    match maybeRecord with
    | None => False
    | Some record =>
      match record with 
      | Record owner _ =>
        builtin eq sender owner
      end
    end

let getIsOA = 
  fun(sender: ByStr20) =>
  fun(maybeRecord: Option Record) =>
  fun(maybeApproved: Option ByStr20) =>
    match maybeRecord with
    | None => False
    | Some record =>
      match record with 
      | Record owner _ =>
        let isOkO = builtin eq sender owner in 
        let isOkA = 
          match maybeApproved with
          | None => False
          | Some approved => builtin eq sender approved
          end in 
          andb isOkO isOkA
      end
    end

let getIsOAO =
  fun(sender: ByStr20) =>
  fun(maybeRecord: Option Record) =>
  fun(maybeApproved: Option ByStr20) =>
  fun(operators: Map ByStr20 (List ByStr20)) =>
    let recordOwner = recordMemberOwner maybeRecord in
    let isOwner = builtin eq sender recordOwner in
    let isApproved = 
      match maybeApproved with
      | None => False
      | Some approved => builtin eq sender approved
      end in
    let maybeOperators = builtin get operators recordOwner in
    let isOperator = match maybeOperators with
    | None => False
    | Some operators => listByStr20Contains operators sender
    end in
    let b1 = orb isOwner isApproved in orb b1 isOperator

(* END: Miscilanious Functions *)

(* The 'contract' pragma tells scilla that the contract body starts *)
contract AORegistry 

(* START: Initial Parameters *)
(* Initial Parameters are specified on deploy, in the init.json and cannot be *)
(* changed throughout the life of the contract *)

(* initialOwner specifies the owner of the ZNS Root. See records field below. *)
(initialOwner: ByStr20)

(* END: Initial Parameters *)

(* START: Mutable Fields *)
(* Mutable Fields represent the persistant state of a scilla contract and can *)
(* use the Initial Parameters durring contract instantiation *)

(* records is the representation of the ZNS record tree as a mapping of a *)
(* Node IDs (ByStr32) to ZNS records (Record) *)
(* We initialize the field, so the contracts' initialOwner owns the ZNS root *)
field records: Map ByStr32 Record = 
(* Emp ByStr32 Record *)
  let empty = Emp ByStr32 Record in 
  let rootRecord = Record initialOwner zeroByStr20 in
    builtin put empty zeroByStr32 rootRecord

(* approvals and operators are the internal representation of the erc721 like *)
(* IAM system that ZNS uses *)
field approvals: Map ByStr32 ByStr20 = Emp ByStr32 ByStr20
field operators: Map ByStr20 (List ByStr20) = Emp ByStr20 (List ByStr20)
field admins: List ByStr20 = Cons {ByStr20} initialOwner nilByStr20

(* END: Mutable Fields *)

(* START: Admin Transitions *)
transition setAdmin(address: ByStr20, isApproved: Bool)
  admins <- admins;

  isSenderAdmin = listByStr20Contains admins _sender;

  match isSenderAdmin with
  | True =>
    admins <- admins;

    needsToChange = 
      let b = listByStr20Excludes admins address in xandb b isApproved;

    match needsToChange with
    | True =>
      newAdmins = match isApproved with
        | True => Cons {ByStr20} address admins
        | False => listByStr20FilterOut admins address
        end;

      admins := newAdmins;

      e = eAdminSet address isApproved;
      event e
    | _ => (* Q?: Should I put an event here *)
    end
  | False => 
    e = let m = "Sender not root node owner" in eError m eCodeFailureIAM;
    event e
  end
end

transition approve(node: ByStr32, address: ByStr20) 
  maybeRecord <- records[node];

  isSenderNodeOwner = getIsOwner _sender maybeRecord;

  match isSenderNodeOwner with
  | True =>
    maybeApproved <- approvals[node];

    currentlyApproved = match maybeApproved with
      | None => zeroByStr20
      | Some approved => approved
      end;

    needsToChange = let b = builtin eq currentlyApproved address in negb b;

    match needsToChange with
    | True =>
      approvals[node] := address;

      e = eApproved address;
      event e
    | _ => (* Q?: Should I put an event here *)
    end
  | False => 
    e = let m = "Sender not node owner" in eError m eCodeFailureIAM;
    event e
  end
end

transition approveFor(address: ByStr20, isApproved: Bool)
  maybeOperators <- operators[_sender];

  currentOperators = match maybeOperators with
    | None => nilByStr20
    | Some operators => operators
    end;

  needsToChange = let b = listByStr20Excludes currentOperators address in 
    xandb b isApproved;

  match needsToChange with
  | True =>
    newOperators = match isApproved with 
      | True => Cons {ByStr20} address currentOperators
      | False => listByStr20FilterOut currentOperators address
      end;

    operators[_sender] := newOperators;

    e = eApprovedFor _sender address isApproved;
    event e
  | _ => (* Q?: Should I put an event here *)
  end
end
(* END: Admin Transitions *)

(* START: Name Transitions *)
transition configure(node: ByStr32, owner: ByStr20, resolver: ByStr20) 
  maybeRecord <- records[node];
  maybeApproved <- approvals[node];
  operators <- operators;

  isSenderOAO = getIsOAO _sender maybeRecord maybeApproved operators;

  match isSenderOAO with
  | True =>
    newRecord = Record owner resolver;
    records[node] := newRecord;

    e = eConfigured node owner resolver;
    event e
  | False =>
    e = let m = "Sender not node owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end

transition transfer(node: ByStr32, owner: ByStr20)
  maybeRecord <- records[node];
  maybeApproved <- approvals[node];
  operators <- operators;

  isSenderOAO = getIsOAO _sender maybeRecord maybeApproved operators;

  match isSenderOAO with
  | True =>
    approvals[node] := zeroByStr20;
    newRecord = Record owner zeroByStr20;
    records[node] := newRecord;

    e = eConfigured node owner zeroByStr20;
    event e
  | False =>
    e = let m = "Sender not node owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end

transition assign(parent: ByStr32, label: String, owner: ByStr20)
  maybeRecord <- records[parent];
  maybeApproved <- approvals[parent];
  operators <- operators;

  isSenderOAO = getIsOAO _sender maybeRecord maybeApproved operators;

  match isSenderOAO with
  | True =>
    node = parentLabelToNode parent label;

    recordExists <- exists records[node];
    match recordExists with
    | False =>
      e = eNewDomain parent label;
      event e
    | _ => 
    end;

    newRecord = Record owner zeroByStr20;
    records[node] := newRecord;

    e = eTransfered node owner;
    event e
  | False =>
    e = let m = "Sender not parent owner, approved or operator" in eError m eCodeFailureIAM;
    event e
  end
end
(* END: Name Transitions *)

(* START: Admin Transitions *)
transition bestow(parent: ByStr32, label: String, owner: ByStr20, resolver: ByStr20)
  admins <- admins;
  node = parentLabelToNode parent label;
  recordExists <- exists records[node];
  maybeRecord <- records[node];

  isOk = 
    let isSenderAdmin = listByStr20Contains admins _sender in
    let recordOwner = recordMemberOwner maybeRecord in
    let recordIsUnowned = builtin eq recordOwner zeroByStr20 in
      andb isSenderAdmin recordIsUnowned;

  match isOk with
  | True =>
    match recordExists with
    | False =>
      e = eNewDomain parent label;
      event e
    | _ => 
    end;

    newRecord = Record owner resolver;
    records[node] := newRecord;

    e = eTransfered node owner;
    event e
  | False =>
    e = let m = "Sender admin" in eError m eCodeFailureIAM;
    event e
  end
end
(* END: Admin Transitions *)

(* START: Reciever Transitions *)
transition sendZNSRecordTo(address: ByStr20, parent: ByStr32, label: String)
  accept;

  node = parentLabelToNode parent label;
  maybeRecord <- records[node];

  msgs = 
    let msg = 
      match maybeRecord with
      | None =>
        {_tag: "onZNSRecordReceived"; _amount: _amount; _recipient: address; 
         origin: _sender; node: node; parent: parent; label: label; 
         owner: zeroByStr20; resolver: zeroByStr20}
      | Some record =>
        match record with
        | Record owner resolver =>
          {_tag: "onZNSRecordReceived"; _amount: _amount; _recipient: address; 
           origin: _sender; node: node; parent: parent; label: label; 
           owner: owner; resolver: resolver}        
        end
      end in 
      oneMsg msg;

  send msgs
end
(* END: Reciever Transitions *)
