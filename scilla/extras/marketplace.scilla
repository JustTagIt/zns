scilla_version 0

import BoolUtils IntUtils ListUtils NatUtils PairUtils

library MarketplaceLib

let nilMessage = Nil {Message}

let oneMsg =
  fun(msg: Message) =>
    Cons {Message} msg nilMessage

let ePurchase =
  fun(node: ByStr32) =>
  fun(amount: Uint128) =>
  fun(owner: ByStr20) =>
    {_eventname: "Purchase"; node: node; amount: amount; owner: owner}

let eError =
  {_eventname: "Error"}

let eWithdraw =
  fun(depositee: ByStr20) =>
  fun(amount: Uint128) =>
  fun(address: ByStr20) =>
    {_eventname: "Withdraw"; depositee: depositee; amount: amount; 
     address: address}

let eListed =
  fun(sender: ByStr20) =>
  fun(node: ByStr32) =>
  fun(amount: Uint128) =>
    {_eventname: "Listed"; sender: sender; node: node; amount: amount}

contract Marketplace(
  registry: ByStr20
)

field listings: Map ByStr20 (Map ByStr32 Uint128) = Emp ByStr20 (Map ByStr32 Uint128)
field deposits: Map ByStr20 Uint128 = Emp ByStr20 Uint128

transition onZNSRecordReceived(
  origin: ByStr20, 
  node: ByStr32, 
  parent: ByStr32, 
  label: String, 
  owner: ByStr20, 
  resolver: ByStr20,
  approved: ByStr20
)
  accept;

  maybeListing <- listings[owner][node];

  isOk = 
    let isOkSender = builtin eq _sender registry in
    let isThisApproved = builtin eq _this_address apporved in
    let isOkListingAndAmount = 
      match maybeListing with
      | None => False
      | Some listing => builtin eq listing _amount
      end in
    let isOkAddresses = andb isOkSender isThisApproved in
      andb isOkListingAndAmount isOkAddresses;

  match isOk with
  | True =>
    maybeDeposit <- deposits[origin];
    newDeposit = 
      match maybeDeposit with
      | None => _amount
      | Some deposit => builtin add _amount deposit
      end;
    deposits[origin] := newDeposit;

    e = ePurchase node _amount origin;
    event e;

    msgs = let m = {_tag: "transfer"; _recipient: registry; _amount: Uint128 0; 
                    node: node; owner: origin} in 
      oneMsg m;
    send msgs
  | False =>
    event eError;
    msgs = let m = {_tag: ""; _recipient: registry; _amount: _amount} in 
      oneMsg m;
    send msgs
  end
end

transition list(node: ByStr32, price: Uint128)
  listings[_sender][node] := price;

  e = eListed _sender node price;
  event e
end

transition withdraw(address: ByStr20)
  maybeDeposit <- deposits[_sender];
  match maybeDeposit with
  | Some deposit =>
    delete deposits[_sender];

    e = eWithdraw _sender _amount address;
    event e;

    msgs = let m = {_tag: ""; _recipient: address; _amount: deposit} in 
      oneMsg m;
    send msgs
  | None =>
    event eError
  end
end
