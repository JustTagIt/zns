scilla_version 0

import BoolUtils IntUtils ListUtils NatUtils PairUtils

library AuctionRegistrarLib

let oneMsg =
  fun(msg: Message) =>
    let nilMsg = Nil {Message} in
    Cons {Message} msg nilMsg

type Auction = 
| Auction of ByStr20 Uint128 BNum String
(* Leader, Current Bid, Ending Block, Label *)

let calcMinimumBid = 
  fun(bidIncrementNumerator: Uint128) => 
  fun(bidIncrementDenominator: Uint128) => 
  fun(currentBid: Uint128) =>
    let f1 = builtin add bidIncrementNumerator bidIncrementDenominator in
    let f2 = builtin div currentBid bidIncrementDenominator in
      builtin mul f1 f2

let calcEndingBlk =
  fun(minimumAuctionLength: Uint64) => 
  fun(blk: BNum) => 
  fun(endingBlk: BNum) =>
    let minAuctionEnding = builtin badd blk minimumAuctionLength in
    let isCurrentEndingBlkTooShort = 
      builtin blt endingBlk minAuctionEnding in
      match isCurrentEndingBlkTooShort with
      | True => minAuctionEnding
      | False => endingBlk
      end

let eRunningSet =
  fun(running: Bool) =>
    {_eventname: "RunningSet"; running: running}

let eStart =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
  fun(endingBlk: BNum) =>
    {_eventname: "Start"; node: node; bidder: bidder; bid: bid; 
     endingBlk: endingBlk}

let eBid =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
  fun(endingBlk: BNum) =>
    {_eventname: "Bid"; node: node; bidder: bidder; bid: bid; 
     endingBlk: endingBlk}

let eClose =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
    {_eventname: "Close"; node: node; bidder: bidder; bid: bid}

let eError =
  fun(message: String) =>
    {_eventname: "Error"; message: message}

contract AuctionRegistrar(
  owner: ByStr20,
  registry: ByStr20,
  ownedNode: ByStr32,
  bidIncrementNumerator: Uint128,
  bidIncrementDenominator: Uint128,
  initialMinimumBid: Uint128,
  minimumAuctionLength: Uint64,
  initialAuctionLength: Uint64
)

field running: Bool = False
field auctions: Map ByStr32 Auction = Emp ByStr32 Auction 

transition onZNSRecordReceived(
  origin: ByStr20, 
  node: ByStr32, 
  parent: ByStr32, 
  label: String, 
  owner: ByStr20, 
  resolver: ByStr20
)
  accept;

  auctionExists <- exists auctions[node];

  match auctionExists with
  | False =>
    isRunning <- running;

    isOk = 
      let isOkSender = builtin eq _sender registry in
      let isOkAmount = builtin lt initialMinimumBid _amount in
      let isOkRequest = andb isOkSender isOkAmount in
        andb isOkRequest isRunning;

    match isOk with
    | True =>
      blk <- & BLOCKNUMBER;
      endingBlk = builtin badd blk initialAuctionLength;
      newAuction = Auction origin _amount endingBlk label;

      auctions[node] := newAuction;

      e = eStart node origin _amount endingBlk;
      event e

      msg = {_tag: "bestow"; _recipient: registry; _amount: Uint128 0; 
             parent: ownedNode; label: label; owner: _this_address};
      msgs = oneMsg msg;
      send msgs
    | False =>
      e = let m = "Auctions are not running or invalid amount sent" in eError m;
      event e;
 
      msgs = 
        let msg = {_tag: ""; _recipient: origin; _amount: _amount} in
          oneMsg msg;
      send msgs
    end
  | True =>
    e = let m = "Auction already exists" in eError m;
    event e;
 
    msgs = 
      let msg = {_tag: ""; _recipient: origin; _amount: _amount} in
        oneMsg msg;

    send msgs
  end
end

transition bid(node: ByStr32)
  maybeAuction <- auctions[node];

  match maybeAuction with
  | None =>
  | Some auction =>
    match auction with
    | Auction highestBidder currentBid endingBlk label =>
      blk <- & BLOCKNUMBER;

      isOk = 
        let minBid = calcMinimumBid bidIncrementNumerator bidIncrementDenominator currentBid in
        let isOkAmount = builtin lt minBid _amount in
        let isOkBlk = builtin blt blk endingBlk in
          andb isOkAmount isOkBlk;

      match isOk with
      | True =>
        newEndingBlk = calcEndingBlk minimumAuctionLength blk endingBlk;
        newAuction = Auction _sender _amount newEndingBlk label;

        auctions[node]:= newAuction;

        accept;

        e = eBid node _sender _amount newEndingBlk;
        event e;

        msgs = 
          let msg = {_tag: ""; _recipient: highestBidder; _amount: currentBid} in
            oneMsg msg;

        send msgs
      | _ =>
      end
    end
  end
end

transition close(node: ByStr32)
  maybeAuction <- auctions[node];

  match maybeAuction with
  | None =>
  | Some auction => 
    match auction with
    | Auction highestBidder currentBid endingBlk label => 
      blk <- & BLOCKNUMBER;
      isOkBlk = builtin blt endingBlk blk;

      match isOkBlk with
      | True =>
        delete auctions[node];
        e = eClose node highestBidder currentBid;

        msg = {_tag: "assign"; _recipient: registry; _amount: Uint128 0; 
              parent: ownedNode; label: label; owner: highestBidder};
        msgs = oneMsg msg;
        send msgs
      | _ => 
      end
    end
  end
end

transition setRunning(newRunning: Bool)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True => 
    running := newRunning;
    e = eRunningSet newRunning;
    event e
  | _ =>
  end
end

transition withdraw(address: ByStr20, amount: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    msg = {_tag: ""; _recipient: address; _amount: amount};
    msgs = oneMsg msg;
    send msgs
  | _ =>
  end
end