scilla_version 0

import BoolUtils IntUtils ListUtils NatUtils PairUtils

library AuctionRegistrarLib

let zeroByStr20 = 0x0000000000000000000000000000000000000000

let oneMsg =
  fun(msg: Message) =>
    let nilMsg = Nil {Message} in
    Cons {Message} msg nilMsg

type Auction = 
| Auction of ByStr20 Uint128 BNum String
(* Bidder, Current Bid, Ending Block, Label *)

let calcMinimumBid = 
  fun(bidIncrementNumerator: Uint128) => 
  fun(bidIncrementDenominator: Uint128) => 
  fun(currentBid: Uint128) =>
    let f1 = builtin add bidIncrementNumerator bidIncrementDenominator in
    let f2 = builtin div currentBid bidIncrementDenominator in
      builtin mul f1 f2

let calcEndingBlk =
  fun(minimumAuctionLength: Uint64) => 
  fun(blk: BNum) => 
  fun(endingBlk: BNum) =>
    let minAuctionEnding = builtin badd blk minimumAuctionLength in
    let isCurrentEndingBlkTooShort = 
      builtin blt endingBlk minAuctionEnding in
      match isCurrentEndingBlkTooShort with
      | True => minAuctionEnding
      | False => endingBlk
      end

let eRunningSet =
  fun(running: Bool) =>
    {_eventname: "RunningSet"; running: running}

let eStart =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
  fun(endingBlk: BNum) =>
    {_eventname: "Start"; node: node; bidder: bidder; bid: bid; 
     endingBlk: endingBlk}

let eBid =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
  fun(endingBlk: BNum) =>
    {_eventname: "Bid"; node: node; bidder: bidder; bid: bid; 
     endingBlk: endingBlk}

let eClose =
  fun(node: ByStr32) =>
  fun(bidder: ByStr20) =>
  fun(bid: Uint128) =>
    {_eventname: "Close"; node: node; bidder: bidder; bid: bid}


let eLiPricePerUSDSet =
  fun(price: Uint128) =>
    {_eventname: "LiPricePerUSDSet"; price: price}

let eDefaultPriceUSDSet =
  fun(price: Uint128) =>
    {_eventname: "DefaultPriceUSDSet"; price: price}

let eMaxPriceUSDSet =
  fun(price: Uint128) =>
    {_eventname: "MaxPriceUSDSet"; price: price}

let eLengthPriceUSDSet =
  fun(length: Uint32) =>
  fun(price: Uint128) =>
    {_eventname: "LengthPriceUSDSet"; length: length; price: price}

let eCustomPriceUSDSet =
  fun(node: ByStr32) =>
  fun(price: Uint128) =>
    {_eventname: "CustomPriceUSDSet"; node: node; price: price}
  
let eError =
  fun(message: String) =>
    {_eventname: "Error"; message: message}

contract AuctionRegistrar(
  owner: ByStr20,
  registry: ByStr20,
  ownedNode: ByStr32,
  initialAuctionLength: Uint64,
  minimumAuctionLength: Uint64,
  initialDefaultPrice: Uint128,
  bidIncrementNumerator: Uint128,
  bidIncrementDenominator: Uint128,
  initialPricePerLi: Uint128,
  initialMaxPriceUSD: Uint128
)

field running: Bool = False
field auctions: Map ByStr32 Auction = Emp ByStr32 Auction 

field liPerUSD: Uint128 = initialPricePerLi
field defaultPriceUSD: Uint128 = initialDefaultPrice
field lengthPricesUSD: Map Uint32 Uint128 = Emp Uint32 Uint128
field customPricesUSD: Map ByStr32 Uint128 = Emp ByStr32 Uint128
field maxPriceUSD: Uint128 = initialMaxPriceUSD

transition setLiPricePerUSD(newPrice: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    e = eLiPricePerUSDSet newPrice;
    event e;

    liPerUSD := newPrice
  | _ =>
  end
end

transition setDefaultPriceUSD(newPrice: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    e = eDefaultPriceUSDSet newPrice;
    event e;

    defaultPriceUSD := newPrice
  | _ =>
  end
end

transition setMaxPriceUSD(newPrice: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    e = eMaxPriceUSDSet newPrice;
    event e;

    maxPriceUSD := newPrice
  | _ =>
  end
end

transition setLengthPriceInUSD(length: Uint32, newPrice: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    e = eLengthPriceUSDSet length newPrice;
    event e;

    lengthPricesUSD[length] := newPrice
  | _ =>
  end
end

transition setCustomPriceInUSD(node: ByStr32, newPrice: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    e = eCustomPriceUSDSet node newPrice;
    event e;

    customPricesUSD[node] := newPrice
  | _ =>
  end
end


transition register(
  origin: ByStr20, 
  node: ByStr32, 
  parent: ByStr32,
  label: String
)
  accept;

  auctionExists <- exists auctions[node];

  match auctionExists with
  | False =>
    isRunning <- running;

    maybeCustomPriceUSD <- customPricesUSD[node];
    labelLen = builtin strlen label;
    maybeLengthPriceUSD <- lengthPricesUSD[labelLen];
    currentDefaultPriceUSD <- defaultPriceUSD;
    currentLiPerUSD <- liPerUSD;

    price =
      let priceUSD = 
        match maybeCustomPriceUSD with
        | Some customPriceUSD => customPriceUSD
        | None => 
          match maybeLengthPriceUSD with
          | Some lenthPriceUSD => lenthPriceUSD
          | None => currentDefaultPriceUSD
          end
        end in
        builtin mul priceUSD currentLiPerUSD;

    isOk = 
      let isOkParent = builtin eq ownedNode parent in
      let isOkSender = builtin eq registry _sender in
      let isOkAmount = builtin lt price _amount in
      let isOkRequest = andb isOkSender isOkAmount in
      let isOk = andb isOkParent isOkRequest in
        andb isOk isRunning;

    match isOk with
    | True =>
      currentMaxPriceUSD <- maxPriceUSD;

      maxPrice = builtin mul currentMaxPriceUSD currentLiPerUSD;
      paidMaxPrice = builtin lt _amount maxPrice;

      match paidMaxPrice with
      | True =>
        e = eClose node origin _amount;
        event e;

        msgs = 
          let m = {_tag: "bestow"; _recipient: registry; _amount: Uint128 0; 
                  parent: ownedNode; label: label; owner: origin; 
                  resolver: zeroByStr20} in
          oneMsg m;
        send msgs
      | False => 
        blk <- & BLOCKNUMBER;
        endingBlk = builtin badd blk initialAuctionLength;
        newAuction = Auction origin _amount endingBlk label;

        auctions[node] := newAuction;

        e = eStart node origin _amount endingBlk;
        event e;

        msgs = 
          let m = {_tag: "bestow"; _recipient: registry; _amount: Uint128 0; 
                  parent: ownedNode; label: label; owner: _this_address; 
                  resolver: zeroByStr20} in
          oneMsg m;
        send msgs
      end
    | False =>
      e = let m = "Auctions are not running or invalid amount sent" in eError m;
      event e;

      msgs = 
        let m = {_tag: ""; _recipient: origin; _amount: _amount} in
          oneMsg m;
      send msgs
    end
  | True =>
    e = let m = "Auction already exists" in eError m;
    event e;
 
    msgs = 
      let m = {_tag: ""; _recipient: origin; _amount: _amount} in
        oneMsg m;
    send msgs
  end
end

transition bid(node: ByStr32)
  maybeAuction <- auctions[node];

  match maybeAuction with
  | None =>
  | Some auction =>
    match auction with
    | Auction highestBidder currentBid endingBlk label =>
      blk <- & BLOCKNUMBER;

      isOk = 
        let minBid = calcMinimumBid bidIncrementNumerator bidIncrementDenominator currentBid in
        let isOkAmount = builtin lt minBid _amount in
        let isOkBlk = builtin blt blk endingBlk in
          andb isOkAmount isOkBlk;

      match isOk with
      | True =>
        currentLiPerUSD <- liPerUSD;
        currentMaxPriceUSD <- maxPriceUSD;

        maxPrice = builtin mul currentMaxPriceUSD currentLiPerUSD;
        paidMaxPrice = builtin lt _amount maxPrice;

        match paidMaxPrice with
        | True =>
          delete auctions[node];
          e = eClose node highestBidder currentBid;
          event e;

          msg = {_tag: "assign"; _recipient: registry; _amount: Uint128 0; 
                parent: ownedNode; label: label; owner: highestBidder};
          msgs = oneMsg msg;
          send msgs
        | False =>
          newEndingBlk = calcEndingBlk minimumAuctionLength blk endingBlk;
          newAuction = Auction _sender _amount newEndingBlk label;

          auctions[node] := newAuction;

          accept;

          e = eBid node _sender _amount newEndingBlk;
          event e;

          msgs = 
            let msg = {_tag: ""; _recipient: highestBidder; _amount: currentBid} in
              oneMsg msg;

          send msgs
        end
      | _ =>
      end
    end
  end
end

transition close(node: ByStr32)
  maybeAuction <- auctions[node];

  match maybeAuction with
  | None =>
  | Some auction => 
    match auction with
    | Auction highestBidder currentBid endingBlk label => 
      blk <- & BLOCKNUMBER;
      isOkBlk = builtin blt endingBlk blk;

      match isOkBlk with
      | True =>
        delete auctions[node];
        e = eClose node highestBidder currentBid;
        event e;

        msg = {_tag: "assign"; _recipient: registry; _amount: Uint128 0; 
              parent: ownedNode; label: label; owner: highestBidder};
        msgs = oneMsg msg;
        send msgs
      | _ => 
      end
    end
  end
end

transition setRunning(newRunning: Bool)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True => 
    running := newRunning;
    e = eRunningSet newRunning;
    event e
  | _ =>
  end
end

transition withdraw(address: ByStr20, amount: Uint128)
  isOkSender = builtin eq _sender owner;

  match isOkSender with
  | True =>
    msg = {_tag: ""; _recipient: address; _amount: amount};
    msgs = oneMsg msg;
    send msgs
  | _ =>
  end
end